package main

import (
	"flag"
	"fmt"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"net"
	"net/http"
	"os"
	"sync"
)

const (
	CONN_HOST = "localhost"
	CONN_PORT = "3333"
	CONN_TYPE = "tcp"
)

func main() {
	host := flag.String("host", "localhost:3333", "tcp host")
	addr := flag.String("address", ":8080", "http address")
	path := flag.String("uri", "/metrics", "the metrics scrape path")

	lis, err := net.Listen("tcp", *host)

	if err != nil {
		panic(err)
	}

	defer func() {
		err = lis.Close()

		if err != nil {
			panic(err)
		}
	}()

	wg := sync.WaitGroup{}

	wg.Add(1)

	go func() {
		defer wg.Done()

		for {
			conn, err := lis.Accept()

			if err != nil {
				println(err)

				return
			}

			go handleRequest(conn)
		}
	}()

	mux := http.NewServeMux()

	mux.Handle(*path, promhttp.Handler())

	wg.Add(1)

	go func() {
		defer wg.Done()

		err = http.ListenAndServe(*addr, mux)

		if err != nil {
			println(err)
		}
	}()

	wg.Wait()
}

// Handles incoming requests.
func handleRequest(conn net.Conn) {
	// Make a buffer to hold incoming data.
	buf := make([]byte, 1024)
	// Read the incoming connection into the buffer.
	reqLen, err := conn.Read(buf)
	if err != nil {
		fmt.Println("Error reading:", err.Error())
	}
	// Send a response back to person contacting us.
	conn.Write([]byte("Message received."))
	// Close the connection when you're done with it.
	conn.Close()
	i, e :=prometheus.DefaultGatherer.Gather()

}
